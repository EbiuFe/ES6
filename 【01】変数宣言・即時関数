------------------------------------------------------
変数宣言、即時関数について
------------------------------------------------------

■変数宣言
-　-　-　-　-　-　-　-　-　-　-
＜ポイント＞
　・ES5以前は、varしかなかった。
　・ES6で、「let」「const」が追加された。
　・いまのところ、'use strict'を使わないと動かない。
　・ブロックスコープを生成するため、変数の干渉を気にせずに使用できる(かも)。

＜宣言について＞
（1）「let」宣言：　「再宣言ができない」宣言のもの。
	******************************************
	<code>
	'use strict'

	var spam = 12;// 当然よろしい
	var spam = 13;// （再宣言）これもオッケー
	console.log(spam);//13

	let ham = 15;//大丈夫
	ham = 17;//（データ入れ替え）問題なし
	console.log(ham);

	let ham = 12;//（再宣言）こいつはダメ
	</code>
	******************************************

（2）「const」宣言：「定数」を宣言するもの。
	これまでのvarだと常に値が書き換わるリスクをはらんでいた。（個人的な推測ですが、いろいろなプラグインの導入や様々な機能の追加で、コアの機能が壊れる可能性をそういうリスクって言ってるのかなと）
	「大文字で変数を定義し、定数として使用している変数である」とする暗黙のルールで運用されることもあったそう。
	******************************************
	<code>
	'use strict'

	const TEST = 11;//大丈夫
	TEST = 12; //（宣言時の値を変えれない）代入ができない　エラーが返ってくる
	</code>
	******************************************
					
	constの注意点は、オブジェクトの書き換えができること。
	******************************************
	<code>
	const TEST = {
	       a: 1,
	       b: 0
	   };
	TEST.a = 3;
	console.log(TEST);//Object {a: 3, b: 0}
	</code>
	******************************************

	もしconstをオブジェクト形式で設定する場合は、下記のように設定することがおすすめ
	******************************************
	<code>
	const TEST = Object.freeze({
	       a: 1,
	       b: 0
	   });
	TEST.a = 3;
	console.log(TEST);//Cannot assign to read only property 'a' of object '#&lt;Object&gt;'
	</code>
	******************************************
	オブジェクトを凍結でき、書き換えられる心配がなくなる。


＜共通の特徴＞
（1）let・constでは、ブロック単位でスコープを生成。
※スコープ:変数の有効範囲のことで、プログラムのどの場所から参照できるかを決める概念。
	******************************************
	<code>
	for (var i = 0; i &lt; 10; i++) {
		console.log(i); // 1~9まででる
	}
	console.log(i); //10がでる

	//	var = i;がない場合でも巻き上げ(ホイスト)により同様
	for (i = 0; i &lt; 10; i++) {
		console.log(i); // 1~9まででる
	}
	console.log(i); //10がでる
	</code>
	******************************************

（2）letで変数を宣言すると、有効範囲がfor分内に限られるので、iは他からアクセスできなくなる。
	******************************************
	<code>
	for (let i = 0; i &lt; 10; i++) {
	　　　　console.log(i); // 1~9まででる
	}
	console.log(i); //ReferenceError: i is not defined
	</code>
	******************************************

	ホイストとブロックスコープでの問題
	例：".button"という要素があり、それを各クリックしたときに順番の数値を出すという実装
	******************************************
	<code>
	var $btns = $(".button"); //10個あったとする
	 
	for (var i=0,len=$btns.length; i&lt;len; ++i) {
	 
	  $btns.eq(i).on('click',function(){
	     console.log(i);
	　　　// どれ押しても10しか出てこない
	  });
	}
	</code>
	******************************************
	letでやると、
	******************************************
   	<code>
	let $btns = $(".button"); //10個あったとする
	 
	for (let i=0,len=$btns.length; i&lt;len; ++i) {
	 
	  $btns.eq(i).on('click',function(){
	     console.log(i);
	     // それぞれ 0.1.2 と出てくる
	  });
	}
	</code>
	******************************************
	let・constではホイストが起きない。
	※ホイスト：変数の巻き上げ現象(宣言しないでいきなり使うと、書いていない宣言を補完して、エラーとせずに"undefined"を返すこと。)
	※ES5以前は変数宣言はブロックスコープの先頭に巻き上げられるため、宣言する前でその変数を利用した場合、エラーにならずundefinedとなっていたが、constとletを使うことでReferenceErrorが発生するようになった。



■即時関数
-　-　-　-　-　-　-　-　-　-　-
＜ポイント＞
・即時関数は、関数を定義すると同時に実行するための構文。
・その名の通り「即時実行される無名関数」のこと。即時実行できる無名の関数とはつまり、「グローバルの名前を全く潰さず、ローカルのスコープを作り出しそのまま処理を実行できる」ということ。
・即時関数を使う理由は、スコープの汚染を防ぐため
　JavaScriptのスコープは、「グローバルスコープ」と「関数スコープ」のみ。すなわち関数は任意にスコープを作るための唯一の手段。
・処理が再利用されないのであれば、即時関数を使うべき。
・名前付き関数との主な用途の違いは、再利用するかどうか。
・スコープを作るためだけなら、｛｝でのブロックスコープで代用できる。

＜特徴＞
（1）基本的な書き方
	******************************************
   	<code>
	(function () {
	    //処理
	}());
	</code>
	******************************************

	引数をもたせられる
	******************************************
	<code>
	(function (param1, param2) {
	    //処理
		console.log(param1); //'hoge'が出力される。
		console.log(param2); //'fuga'が出力される。
	}('hoge', 'fuga'));
	</code>
	******************************************

	返り値を持つことができる
	******************************************
	<code>
	var result = (function (param1, param2) {
	    return param1 + param2;
	}(1, 2));
	console.log(result); //3が出力される。
	</code>
	******************************************

＜使いどころ＞
（1）ページの初期化
　・load時にのみ処理するものは以降必要でない、残っていてはリスクなだけ。

（2）プライベートプロパティ／メソッドの定義
　・オブジェクト内に定義されたプロパティ/メソッドはすべてパブリックなものとして扱われる。
　しかし、即時関数やクロージャを利用すればプライベートなプロパティ／メソッドを定義することが可能。
	******************************************
   	<code>
	var counter = (function () {
	        //プライベートにしたいプロパティ
	        var count = 0;

	        return {
	            //加算メソッド
	            increment: function () {
	                count += 1;
	                console.log(count);
	            }
	        };
	    }());
	counter.increment(); //1が出力される
	counter.increment(); //2が出力される

	console.log(counter.count); //※undefined
	</code>
	******************************************

（3）結論？使いどころほとんどなし。
　スコープを作るだけなら・・・{}で代用できる。

	before
	******************************************
   	<code>
	(function() {
	  var num = 1;
	}())
	console.log(num); // エラー
	</code>
	******************************************

	after
	******************************************
	<code>
	{
	  let num = 1;
	}
	console.log(num); // エラー
	</code>
	******************************************



■参考文献
-　-　-　-　-　-　-　-　-　-　-

http://liginc.co.jp/267624
https://html5experts.jp/1000ch/16984/
http://qiita.com/niisan-tokyo/items/bacb5ed98ea10831eeba
http://qiita.com/takeharu/items/cbbe017bbdd120015ca0
http://qiita.com/katsukii/items/cfe9fd968ba0db603b1e
http://iwb.jp/es2015-es6-immediate-function-let/
http://wp-p.info/tpl_rep.php?cat=js-intermediate&fl=r11
http://wp-p.info/tpl_rep.php?cat=js-intermediate&fl=r10
